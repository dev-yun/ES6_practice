{"mappings":"AAAA,kEAAkC;AAEF,sEAAY;AAClB,MAApB,MAAM,GAAG,IAAI,MAAM,AAAC;AAE1B,8GAAoD;AACM,oGAAd;AACY,MAAlD,MAAM,GAAG;IACX,GAAG,EAAG,EAAE;IACR,IAAI,EAAG,KAAK;IACZ,GAAG,EAAG,MAAM;IACZ,IAAI,EAAG,GAAG;IACV,KAAK,EAAG,IAAI;IACZ,KAAK,EAAG,KAAK;CAChB;AAED,+BAAe;AACC,MAAV,CAAC,GAAG,CAAC;AACX,MAAM,CAAC,KAAK,CAAC,CAAC;AACd,sGAAwD;AACV,kDAAR;AAC1B,MAAN,CAAC,IAAI,CAAC,CAAI,6BAAa;;AAEb,gBAAR;AACA,MAAF,CAAC,GAAG,GAAG,EAAE,CAAC;AAEhB,gBAAQ;AACA,MAAF,CAAC,IAAI,GAAG,SAAS,CAAC;AAExB,gBAAQ;AACA,OAAD,MAAM,CAAC,IAAI,CAAC;AACnB,+GAAqD;AACK,wCAAtC;AACA,MAAd,CAAC,GAAG,GAAG,IAAI,CAAC;AAElB,8EAAkC;AACU,SAAnC,OAAO,GAAG,EAAG;AACtB,OAAO,CAAC,CAAC,GAAG,8EAAkB,CAAyB;AAC/B,MAAlB,MAAM,GAAG,EAAE,AAAC;AAClB,MAAM,CAAC,CAAC,GAAG,8EAAkB,CAAyB;AAC9B,OAAjB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACvB,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAEtB,+DAA2B;AACS,MAA9B,KAAK,GAAG;IACV,GAAG,EAAG,IAAM,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC;CAC1C;AACD,KAAK,CAAC,GAAG,EAAE,CAAC;AAEZ,sBAAU;AACE,8GAA4C;AACF,OAA/C,CAAC,GAAG,CAAC,AAAC,CAAA,CAAC,GAAG;IAAC,IAAI,EAAG,KAAK;CAAC,CAAA,KAAO,CAAA,CAAC,GAAG;IAAC,IAAI,EAAG,KAAK;CAAC,CAAA,AAAC,CAAC,CAAC,CAAE,QAAQ;AACrE,8DAA0B;AAC1B,MAAM,CAAC,GAAG;IAAC,IAAI,EAAG,KAAK;CAAC,AAAC;AACzB,MAAM,IAAI,GAAG;IAAC,CAAC;CAAC,AAAC;AACjB,OAAO,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC","sources":["Documents/ES6_practice/js/object.js"],"sourcesContent":["// 객체 생성 방법 : 1. 생성자 함수, 2. 객체 리터럴\r\n\r\n// 1. 생성자 함수 : const 변수 = new Object 형식으로 만듬\r\nconst object = new Object;\r\n\r\n// 2. 객체 리터럴 : 관계가 있는 요소들을 (속성 이름 : 속성 값)으로 묶어 표현한 것\r\n// 속성명은 숫자가 제일 앞이거나, 공백이 있거나 -이 있으면 ''로 감싸야함\r\nconst myInfo = {\r\n    age : 26,\r\n    name : 'yun',\r\n    sex : 'male',\r\n    '2a' : 'a',\r\n    'a b' : 'ab',\r\n    'a-b' : 'a-b',\r\n}\r\n\r\n// 객체 접근 방법 2가지\r\nmyInfo.age;\r\nmyInfo['age'];\r\n// 두개가 있는 이유는 위에서 살펴본 '2a', 'a b', 'a-b' 처럼 ''로 감싼 값 때문임\r\n// myInfo.2a : 다른 값, myInfo.'2a' : 불가능\r\nmyInfo['2a']    // 이렇게만 표현 가능\r\n\r\n// 객체 수정\r\nmyInfo.age = 30;\r\n\r\n// 객체 추가\r\nmyInfo.city = 'daejeon';\r\n\r\n// 객체 삭제\r\ndelete myInfo.city;\r\n// 하지만 delete로 삭제하면 메모리상 city는 계속 남아있게됨.(객체와 연결만 끊은것)\r\n// 때문에 null을 사용하길 권장\r\nmyInfo.age = null;\r\n\r\n// 객체리터럴 이외에 함수와 배열도 객체이다. (특수 객체)\r\nfunction objFunc() { }\r\nobjFunc.a = \"함수도 객체의 특성을 갖는다.\";\r\nconst objArr = [];\r\nobjArr.b = \"배열도 객체의 특성을 갖는다.\";\r\nconsole.log(objFunc.a);\r\nconsole.log(objArr.b);\r\n\r\n// 객체 내부에 선언한 함수를 메서드라고 한다.\r\nconst debug = {\r\n    log : () => console.log('hello world!'),\r\n}\r\ndebug.log();\r\n\r\n// 객체간의 비교\r\n// 객체{} === 객체{} 는 항상 false를 출력한다. (같은 값이여도 메모리상 주소가 다름)\r\nconsole.log((a = {name : 'yun'}) === (a = {name : 'yun'}));  // false\r\n// 때문에 객체를 따로 저장하고 비교해야한다.\r\nconst b = {name : 'yun'};\r\nconst arr2 = [b];\r\nconsole.log(b === arr2[0]);\r\n\r\n\r\n\r\n"],"names":[],"version":3,"file":"index.45758dc2.js.map","sourceRoot":"/__parcel_source_root/"}