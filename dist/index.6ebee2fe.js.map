{"mappings":"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","sources":["Documents/ES6_practice/js/array.js"],"sourcesContent":["const array1 = ['나', '다', '라', '마', '바'];\r\n// 배열에 요소 추가 방법\r\n// 1. 가장 앞에 요소 추가 : unshift\r\narray1.unshift('가');\r\nconsole.log(array1);    // ['가', '나', '다', '라', '마', '바']\r\n// 2. 가장 뒤에 요소 추가 : push\r\narray1.push('사');\r\nconsole.log(array1);    // ['가', '나', '다', '라', '마', '바', '사']\r\n\r\n// 배열에 요소 제거 방법\r\n// 3. 첫번째 요소 제거 : shift\r\narray1.shift();\r\nconsole.log(array1);    // ['나', '다', '라', '마', '바', '사']\r\n// 4. 마지막 요소 제거 : pop\r\narray1.pop();\r\nconsole.log(array1);    // ['나', '다', '라', '마', '바']\r\n// 5. 중간 요소 제거 : splice(제거할 요소 위치 입력,제거할 요소부터 몇개를 지울지 입력(입력 안할시 시작지점부터 모두 삭제))\r\narray1.splice(1,1);\r\nconsole.log(array1);    // ['나', '라', '마', '바']\r\n// 5.5 splice는 제거와 동시에 추가도 가능\r\narray1.splice(1,2,'바','사','아');\r\nconsole.log(array1);    // ['나', '바', '사', '아', '바']\r\n\r\n// 추가한 값은 임의의 변수에 대입할 수 없지만, 제거한 값은 임의의 변수에 대입가능\r\n\r\nlet added = array1.unshift('가');\r\n// 5가 출력되는데 array1의 length임\r\nconsole.log(added);     // 6\r\nlet removed = array1.shift();\r\n// 삭제된 '가' 가 할당됨\r\nconsole.log(removed);   // 가\r\n\r\n// 6. 배열에서 요소 검색 : includes  ==> true, false 반환\r\nconst search1 = array1.includes('사');\r\nconsole.log(search1);   // true\r\nconst search2 = array1.includes('하');\r\nconsole.log(search2);   // false\r\n\r\n// 7. 배열에서 요소 검색 2 : indexOf, lastIndexOf  ==> 정확한 요소 위치 반환\r\n// 중복된 값이 있을시 indexOf는 앞에서부터, lastIndexOf는 뒤에서부터 검색, 없는 값이면 -1 반환\r\nconst arrayIndex = array1.indexOf('바');\r\nconsole.log(arrayIndex); // 1\r\nconst arrayIndex2 = array1.lastIndexOf('바');\r\nconsole.log(arrayIndex2); // 4\r\nconst arrayIndex3 = array1.indexOf('하');\r\nconsole.log(arrayIndex3); // -1\r\n\r\n// 배열의 특정 요소 모두 제거 방법\r\nconst arr = ['1', '3', '5', '3', '7', '9', '3', '3', '4' ,'3', '10'];\r\nwhile(true){\r\n    let newIndex = arr.indexOf('3');\r\n    if (newIndex === -1){\r\n        break;\r\n    }\r\n    arr.splice(newIndex ,1);\r\n}\r\nconsole.log(arr);\r\n\r\n\r\n// 배열을 순회하는 방법 중 명령형 프로그래밍과 함수형 프로그래밍\r\n\r\n// 명령형 프로그래밍\r\n\r\nconst arr1 = [];\r\n\r\nfor (const n of [1,2,3,4]){\r\n    arr1.push(n * 2);\r\n}\r\n\r\nconsole.log(arr1);\r\n\r\n// 함수형 프로그래밍\r\n\r\nconst arr2 = [1,2,3,4]\r\n    .map(n => n*2)\r\n    .filter(n => n % 2 !== 0)\r\n    .map(n => `<li>${n}</li>`)\r\n\r\nconsole.log(arr2);\r\n\r\n// 명령형 코드를 함수형처럼 바꾸려면 배우 복잡한 과정을 거친다.\r\n// 하지만 함수형으로 작성하면 각각의 기능이 분리되고 가독성, 재사용성이 모두 뛰어나다.\r\n// 즉, 데이터가 복잡할수록 데이터를 다룰 수 있는 코드를 작은 로직으로 분리하고 이를 결합하여 조합하는 함수형 프로그래밍이 유리하다.  "],"names":[],"version":3,"file":"index.6ebee2fe.js.map","sourceRoot":"/__parcel_source_root/"}